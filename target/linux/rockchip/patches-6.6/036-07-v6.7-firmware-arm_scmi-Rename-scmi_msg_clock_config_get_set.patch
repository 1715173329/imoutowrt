From 8b6022be4c6e3e0d37c3e1378c9ff0a2c8717b09 Mon Sep 17 00:00:00 2001
From: Sudeep Holla <sudeep.holla@arm.com>
Date: Mon, 25 Sep 2023 11:15:57 +0100
Subject: [PATCH] firmware: arm_scmi: Rename
 scmi_{msg_,}clock_config_{get,set}_{2,21}

It is very confusing to use *_v2 for everything applicable until SCMI
clock protocol version v2.0 including v1.0 for example. So let us rename
such that *_v2 is used only for SCMI clock protocol v2.1 onwards. Also
add comment to indicate the same explicitly.

Reviewed-by: Cristian Marussi <cristian.marussi@arm.com>
Link: https://lore.kernel.org/r/20230925101557.3839860-1-sudeep.holla@arm.com
Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
---
 drivers/firmware/arm_scmi/clock.c | 41 +++++++++++++++++--------------
 1 file changed, 22 insertions(+), 19 deletions(-)

--- a/drivers/firmware/arm_scmi/clock.c
+++ b/drivers/firmware/arm_scmi/clock.c
@@ -46,12 +46,13 @@ struct scmi_msg_resp_clock_attributes {
 	__le32 clock_enable_latency;
 };
 
-struct scmi_msg_clock_config_set_v2 {
+struct scmi_msg_clock_config_set {
 	__le32 id;
 	__le32 attributes;
 };
 
-struct scmi_msg_clock_config_set_v21 {
+/* Valid only from SCMI clock v2.1 */
+struct scmi_msg_clock_config_set_v2 {
 	__le32 id;
 	__le32 attributes;
 #define NULL_OEM_TYPE			0
@@ -429,13 +430,13 @@ static int scmi_clock_rate_set(const str
 }
 
 static int
-scmi_clock_config_set_v2(const struct scmi_protocol_handle *ph, u32 clk_id,
-			 enum clk_state state, u8 __unused0, u32 __unused1,
-			 bool atomic)
+scmi_clock_config_set(const struct scmi_protocol_handle *ph, u32 clk_id,
+		      enum clk_state state, u8 __unused0, u32 __unused1,
+		      bool atomic)
 {
 	int ret;
 	struct scmi_xfer *t;
-	struct scmi_msg_clock_config_set_v2 *cfg;
+	struct scmi_msg_clock_config_set *cfg;
 
 	if (state >= CLK_STATE_RESERVED)
 		return -EINVAL;
@@ -457,15 +458,16 @@ scmi_clock_config_set_v2(const struct sc
 	return ret;
 }
 
+/* For SCMI clock v2.1 and onwards */
 static int
-scmi_clock_config_set_v21(const struct scmi_protocol_handle *ph, u32 clk_id,
-			  enum clk_state state, u8 oem_type, u32 oem_val,
-			  bool atomic)
+scmi_clock_config_set_v2(const struct scmi_protocol_handle *ph, u32 clk_id,
+			 enum clk_state state, u8 oem_type, u32 oem_val,
+			 bool atomic)
 {
 	int ret;
 	u32 attrs;
 	struct scmi_xfer *t;
-	struct scmi_msg_clock_config_set_v21 *cfg;
+	struct scmi_msg_clock_config_set_v2 *cfg;
 
 	if (state == CLK_STATE_RESERVED ||
 	    (!oem_type && state == CLK_STATE_UNCHANGED))
@@ -513,10 +515,11 @@ static int scmi_clock_disable(const stru
 				    NULL_OEM_TYPE, 0, atomic);
 }
 
+/* For SCMI clock v2.1 and onwards */
 static int
-scmi_clock_config_get_v21(const struct scmi_protocol_handle *ph, u32 clk_id,
-			  u8 oem_type, u32 *attributes, bool *enabled,
-			  u32 *oem_val, bool atomic)
+scmi_clock_config_get_v2(const struct scmi_protocol_handle *ph, u32 clk_id,
+			 u8 oem_type, u32 *attributes, bool *enabled,
+			 u32 *oem_val, bool atomic)
 {
 	int ret;
 	u32 flags;
@@ -556,9 +559,9 @@ scmi_clock_config_get_v21(const struct s
 }
 
 static int
-scmi_clock_config_get_v2(const struct scmi_protocol_handle *ph, u32 clk_id,
-			 u8 oem_type, u32 *attributes, bool *enabled,
-			 u32 *oem_val, bool atomic)
+scmi_clock_config_get(const struct scmi_protocol_handle *ph, u32 clk_id,
+		      u8 oem_type, u32 *attributes, bool *enabled,
+		      u32 *oem_val, bool atomic)
 {
 	int ret;
 	struct scmi_xfer *t;
@@ -781,11 +784,11 @@ static int scmi_clock_protocol_init(cons
 
 	if (PROTOCOL_REV_MAJOR(version) >= 0x2 &&
 	    PROTOCOL_REV_MINOR(version) >= 0x1) {
-		cinfo->clock_config_set = scmi_clock_config_set_v21;
-		cinfo->clock_config_get = scmi_clock_config_get_v21;
-	} else {
 		cinfo->clock_config_set = scmi_clock_config_set_v2;
 		cinfo->clock_config_get = scmi_clock_config_get_v2;
+	} else {
+		cinfo->clock_config_set = scmi_clock_config_set;
+		cinfo->clock_config_get = scmi_clock_config_get;
 	}
 
 	cinfo->version = version;
